//###### MODELS SCHEMA ######
var model = {
    datasource: '',	//ref to datasource connection info (postgres datasource defined in /datasources/)
    pk: '', //primary key
    table: '', //Associated model table
    auto: '', //Autogenerated code (**optional**)
    columns: {
        field1: 'integer',
        field2: 'string'
    },
    projections: { //Data projections. Used to define some data results(projection) to get diferent data as needed
        'default': {
            find: ['field1', 'field2'],
            save: ['field2'],
            from: 'table',
            countColumn: 'id', //Indicated by which column is the distinct query.
            //Relationated data, and used when we want findOne or saveOne(server controller).
            fk: [], //Use when we have an id of outer table, and we only need one field of this outer table.
            oneToN: [], //Use when we need a collection of an outer table, where fk of outer table is the pk of this model
            NtoM: [] //Use when we need rows of a NM table.

        }
    },
};


//###### FK DEFINITION AND EXAMPLE ######
//In this example an article have group_code('00', for example), and we need the name of this group, so we use fk to get
//the group_deno.
fk : [
    {modelFK: 'Group', column: 'group_code', columnFK: 'code', find: [{'alias': 'group_deno', 'column': 'deno'}]}
]
//modelFK --> outer table of that we want the field.
//column --> column of this model(Article) that contains the value that we want relationate with the outer table(Group) that we need the field.
//columnFK --> column of the outer table that corresponds with column of the fk.
//find --> object that define the way of we want to get the data:
//alias(*opcional*) --> name of the field in our object that contains the value that we need. When alias is null it is the same as alias:'[value of column]', in this case alias:'deno'
//column --> name of the field of outer table that we want.
//In this case the article will have an property group_deno that contains the name of the group with code '00'.

//If we need to make more than one fk over the same table, we need to add a key 'alias' to fk to not collide the query, like:
fk : [
    {modelFK: 'Group', column: 'group_code', columnFK: 'code', find: [{'alias': 'group_deno', 'column': 'deno'}]},
    {
        modelFK: 'Group',
        alias: 'groupAux',
        column: 'group_code',
        columnFK: 'id',
        find: [{'alias': 'group_deno', 'column': 'deno'}]
    }
]


//###### oneToN DEFINITION AND EXAMPLE ######
//in this example one article has N rates, but one rate belongs to one article(1:N).
//Then we want the rates array of this article, so we will use oneToN.
oneToN : [{
    modelN: 'ArticleRate',
    column: 'id',
    columnN: 'article_id',
    orderBy: 'id',
    find: {'column': 'rates', 'projection': 'fromView'}
}]

//modelN --> outer table of that we want the N records.
//column --> column of our model(Article) which we will get the value to filter(where) the records that we want to get from outer table.
//columnN --> column of the outer table that will be used to make the where with column to filter the records that we want.
//orderBy --> column for ordenation default  modelN.pk if exist

//find --> object that define the way of we want to get the data:
//column --> name of the array of results that we want.
//projection --> name of the projection that we want to use on the outer model(Rate), by default 'default'.


//###### NtoM DEFINITION AND EXAMPLE ######
//On this case we will use 3 tables:  article(N table)  |  article_rates(NM table)  |  rates(M table).
//An article may have N rates and one rate may belong to N articles. For this reason an intermediate table is self-generated (article_rates).
NtoM : [{
    model: 'Rate',
    column: 'id',
    modelNM: 'ArticleRate',
    columnN: 'article_id',
    columnM: 'rate_id',
    joinColumnNM: 'id',
    in: true,
    find: {'columns': ['id as rate_id', 'code', 'deno', 'state'], 'columnsNM': [], 'result': 'rates'},
    toSave: true
},
    {
        model: 'Rate',
        column: 'id',
        modelNM: 'ArticleRate',
        columnN: 'article_id',
        columnM: 'rate_id',
        joinColumnNM: 'id',
        in: false,
        find: {'columns': ['id as rate_id', 'code', 'deno', 'state'], 'columnsNM': [], 'result': '_rates'},
        whereR: {'state': 1},
        toSave: false,
        hasGlobalF: true
    }]

NtoM : [
    {
        N: {modelN: 'Article', columnN: 'id'},
        NM: {modelNM: 'ArticleRate', columnN: 'article_id', columnM: 'rate_id'},
        M: {modelM: 'Rate', columnM: 'id'},
        find: {
            column: 'rates',
            columnsNM: [],
            columnsM: [{column: 'id', alias: 'rate_id'}, {column: 'deno', alias: 'rate_deno'}, {
                column: 'code',
                alias: 'rate_code'
            }]
        }
    }
]

//N.modelN --> table that we want to join with the tablaNM.
//N.columnN --> column that contains the field with which we relate to the NM (This corresponds with one of the previous variable fields(model) and usually the pk of the model).
//NM.modelNM --> the intermediate table model generated in the relation NM.
//NM.columnN --> It corresponds to the field of NM table containing the id of the first table (this model).
//NM.columnM --> It corresponds to the field of NM table containing the id of the second table.
//M.columnN --> This model column that contains the value that we want to filter in NM, in this case the id of the article. (This corresponds to a field of this model).
//find --> filtering fields in the select, if you have values in columns or columnsNM uses to select from the respective tables, if not pick the default of each model find the tables.
//column --> the N records related to, in this case to article.
//columnsNM --> make the select on NM table. #1
//columnsM --> make the select on M table. #1
// #1 --> Both use an object with this structure:
//{column:'[name of the column of the table]',alias:'[the name that we want asign to this column]'}


//###### Server Controllers Methods ######
//Both oneToN and NtoM only works when we find or save only one record.
//For this reason we need specific methods on server controllers like findOne and saveOne
//In this example we will use article.

//Usually,for find we need to send from client to server an object like this --> parameters.where = {id:'1'} or parameters.where = {code:'1'}
exports.findOne = {};
exports.findOne.verb = 'get';
exports.findOne.path = '/server/api/article';
exports.findOne.method = function (req, res) {
    var adapter = util.getAdapter(model);
    var reqParams = util.extractReqParams(req);
    var parameters = adapter.validateFindOne(reqParams, model);
    var datamodel = new DataModel();
    adapter.findOne(parameters, function (result) {
        datamodel.code = 200;
        datamodel.msg = 'transaction OK';
        datamodel.result.data = result;
        res.json(datamodel);
    });
};

//For save we send an object with the article in this case.
exports.saveOne = {};
exports.saveOne.verb = 'post';
exports.saveOne.path = '/server/api/article';
exports.saveOne.method = function (req, res) {
    // var dbOperations = [];
    var adapter = util.getAdapter(model);
    var reqBodyParams = req.body;
    var params = {};
    params = adapter.buildSaveOne(reqBodyParams, model);
    var start = new Date().getTime();
    adapter.transaction(params.dbOperations, function (err) {
        var end = new Date().getTime();
        var time = end - start;

        var datamodel = new DataModel();
        if (err) {
            datamodel.code = 400;
            datamodel.msg = 'ERROR: ' + err.detail;
            datamodel.trace = err.message;
        } else {
            if (params.code) {
                datamodel.result.data.push({code: params.code});
            }
            datamodel.code = 200;
            datamodel.msg = 'transaction OK';
        }
        res.json(datamodel);
    });
};
